<chapter id="chapter00">
  
  <title>General Unix and Advanced C</title>

  <sect1 id="everything_is_a_file">
    <title><emphasis>Everything is a file!</emphasis></title>

    <para>An often quoted tenet of UNIX-like systems such as Linux or
    BSD is <emphasis>everything is a file</emphasis>.</para>

    <para>Imagine a file in the context something familiar like a word
    processor.  There are two fundamental operations we could use on
    this imaginary word processing file:</para>

    <orderedlist>
      <listitem><para>Read it (existing saved data from the word processor).</para></listitem>
      <listitem><para>Write to it (new data from the user).</para></listitem>
    </orderedlist>

    <para>Now consider some of the common things attached to a
    computer and how they relate to our fundamental file
    operations:</para>

    <orderedlist>
      <listitem><para>The screen</para></listitem>
      <listitem><para>The keyboard</para></listitem>
      <listitem><para>A printer</para></listitem>
      <listitem><para>A CDROM</para></listitem>
    </orderedlist>

    <para>The screen and printer are both like a write-only file, but
    instead of being stored as bits on a disk the information is
    displayed as dots on a screen or lines on a page. The keyboard is
    like a read only file, with the data coming from keystrokes
    provided by the user.  The CDROM is similar, but rather than
    randomly coming from the user the data is stored directly on the
    disk.</para>

    <para>Thus the concept of a file is a good
    <emphasis>abstraction</emphasis> of either a a sink for, or source
    of, data.  As such it is an excellent abstraction of all the
    devices one might attach to the computer.  This realisation is the
    great power of UNIX and is evident across the design of the entire
    platform.  It is one of the fundamental roles of the operating
    system to provide this abstraction of the hardware to the
    programmer.</para>

    <para>It is probably not too much of a strech to say abstraction
    is <emphasis>the</emphasis> primary concept that underpins all
    modern computing.  No one person can understand everythinig from
    designing a modern user-interface to the internal workings of a
    modern CPU, much less build it all themselves.  To programmers,
    abstractions are the <emphasis>lingua franca</emphasis> that
    allows us to collaborate and invent.</para>

    <para>Learning to navigate across abstractions gives one greater
      insight into how to <emphasis>use</emphasis> the abstractions in
      the best and most innovative ways.  In this book, we are
      concerned with abstractions at the lowest layers; between
      applications and the operating-system and the operating-system
      and hardware.  Above this lies many more layers, each worthy of
      their own books.  As these chapters progress, you will hopefully
      gain some insight into the abstractions presented by a modern
      operating-system.</para>

    <figure>
      <title>Abstraction</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="chapter00/figures/abstraction.eps" format="EPS" />
	</imageobject>
	<imageobject role="fo">
	  <imagedata fileref="chapter00/figures/abstraction.svg"
	  format="SVG" scalefit="1" width="100%" contentdept="100%" />
	</imageobject>
	<imageobject role="html">
	  <imagedata fileref="chapter00/figures/abstraction.png" format="PNG" />
	</imageobject>
	<textobject>
	  <phrase>Can you spot the difference between a CDROM and a keyboard?  As an application programmer, you should not be able to.</phrase>
	</textobject>
      </mediaobject>
    </figure>


  </sect1>

  <sect1 id="abstration">
    <title>Implementing abstraction</title>

      <para>In general, abstraction is implemented by what is
    generically termed an <emphasis>Application Programming
    Interface</emphasis> (API).  API is a somewhat nebulous term that
    means different things in the context of various programming
    endavours.  Fundamentally, a programmer designs a set of functions
    and documents their interface and functionality with the principle
    that the actual implementation providing the API is opaque.</para>

      <para>For example, many large web-applications provide an API
      accessible via HTTP.  Accessing data via this method surely
      triggers many complicated series of remote-procedure calls,
      database queries and data transfer; all of which is opaque to
      the end user who simply receives the contracted data.</para>

      <para>Those familiar with <emphasis>object-oriented</emphasis>
      languages such as Java, Python or C++ would be familiar with the
      abstraction provided by <emphasis>classes</emphasis>.  Methods
      provide the interface to the class, but abstract the
      implementation.</para>

    <sect2>
      <title>Implementing abstraction with C</title>

      <para>A common method used in the Linux Kernel and other large C
      code bases, which lacks a built-in concept of
      object-orientation, is <emphasis>function pointers</emphasis>.
      Learning to read this idom is key to navigating most large C
      code-bases.  By understanding how to read the abstractions
      provided within the code an understanding of internal API
      designs can be built.</para>

      <example id="abstraction-code">
	<title>Abstraction with function pointers</title>
	<programlisting language="c"><xi:include href="chapter00/code/abstraction.c" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>
      </example>

      <para>Code such as the above is the simplest example of
    constructs used repeatedly through the Linux Kernel and other C
    programs.  Lets have a look at some specific elements.</para>

      <para>We start out with a structure that defines the API
    (<computeroutput>struct greet_api</computeroutput>).  The
    functions whose names are encased in parenthesis with a pointer
    marker describe a <emphasis>function
    pointer</emphasis><footnote><para>Often you will see that the
    names of the parameters are omitted, and only the type of the
    parameter is specified.  This allows the implementer to specify
    their own parameter names avoiding warnings from the
    compiler.</para></footnote>.  The function pointer describes the
    <emphasis>prototype</emphasis> of function it must point to;
    pointing it at a function without the correct return type or
    parameters will generate a compiler warning at least; if left in
    code will likely lead to incorrect operation or crashes.</para>

      <para>We then have our implementation of the API.  Often for
    more complex functionality you will see an idiom where API
    implementation functions will only be a wrapper around another
    function that is conventionally prepended with one or or two
    underscores<footnote> <para>A double-underscore function
    <computeroutput>__foo</computeroutput> may conversationally be
    referred to as "dunder foo".</para></footnote>
    (i.e. <computeroutput>say_hello_fn()</computeroutput> would call
    another function
    <computeroutput>_say_hello_function()</computeroutput>).  This has
    several uses; generally it relates to having simpler and smaller
    parts of the API (marshalling or checking arguments, for example)
    separate to more complex implemenation, which often eases the path
    to significant changes in the internal workings whilst ensuring
    the API remains constant.  Our implementation is very simple
    however, and doesn't even need it's own support functions.  In
    various projects, single, double or even triple underscore
    function prefixes will mean different things, but universally it
    is a visual warning that the function is not supposed to be called
    directly from "beyond" the API.</para>

      <para>Second to last, we fill out the function pointers in
    <computeroutput>struct greet_api greet_api</computeroutput>.  The
    name of the function is a pointer, therefore there is no need to
    take the address of the function
    (i.e. <computeroutput>&amp;say_hello_fn</computeroutput>).</para>

      <para>Finally we can call the API functions through the
    structure in <computeroutput>main</computeroutput>.</para>

      <para>You will see this idiom constantly when navigating the
        souce code.  The tiny example below is taken from
        <computeroutput>include/linux/virtio.h</computeroutput> in the
        Linux kernel source to illustrate:</para>

      <example id="virtio-abstraction">
	<title>Abstraction in
	<computeroutput>include/linux/virtio.h</computeroutput></title>
	<programlisting language="c"><xi:include
	href="chapter00/code/virtio.h" parse="text"
	xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>
      </example>

      <para> It's only necessary to vaguely understand that this
        structure is a description of a virtual I/O device.  We can
        see the user of this API (the device driver author) is
        expected to provide a number of functions that will be called
        under various conditions during system operation (when probing
        for new hardware, when hardware is removed, etc).  It also
        contains a range of data; structures which should be filled
        with relevant data.</para>

      <para>Starting with descriptors like this is usually the easiest
      way into understanding the various layers of kernel code.</para>

    </sect2>

    <sect2>
      <title>Libraries</title>

      <para>Libraries have two roles which illustrate
	abstraction.</para>

      <itemizedlist>
	<listitem>
	  <para>Allow programmers to reuse commonly accessed code.</para>
	</listitem>
	<listitem>
	  <para>Act as a <emphasis>black box</emphasis> implementing
	    functionality for the programmer.</para>
	</listitem>
      </itemizedlist>

      <para>For example, a library implementing access to the raw data
        in JPEG files has both the advantage that the many programs
        who wish to access image files can all use the same library
        and the programmers building these programs do not need to
        worry about the exact details of the JPEG file format, but can
        concentrate their efforts on what their program wants to do
        with the image.</para>

      <para>The standard library of a UNIX platform is generically
        referred to as <computeroutput>libc</computeroutput>.  It
        provides the basic interface to the system: fundamental calls
        such as <computeroutput>read()</computeroutput>,
        <computeroutput>write()</computeroutput> and
        <computeroutput>printf()</computeroutput>.  This API is
        described in its entirety by a specification called
        <computeroutput>POSIX</computeroutput>.  It is freely
        available online and describes the many calls that make up the
        standard UNIX API.</para>

      <para>Most UNIX platforms broadly follow the POSIX standard,
      though often differ small but sometimes important ways (hence
      the complexity of the various GNU autotools, which often tries
      to abstract away these differences for you).  Linux has many
      interfaces that are not specified by POSIX; writing applications
      that use them exclusively will make your application less
      portable.</para>

      <para>Libraries are a fundamental abstraction with many details.
      Later chapters will describe how libraries work in much greater
      detail.</para>

    </sect2>

  </sect1>

  <sect1 id="file_descriptors">
    <title>Standard File Descriptors</title>
    <para>Every running program under Unix starts with three files already opened</para>
    <table>
      <title>Standard Files Provided by Unix</title>
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Descriptive Name</entry>
	    <entry>File Number</entry>
	    <entry>Description</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>Standard In</entry>
	    <entry>0</entry>
	    <entry>Input from the keyboard</entry>
	  </row>
	  <row>
	    <entry>Standard Out</entry>
	    <entry>1</entry>
	    <entry>Output to the console</entry>
	  </row>
	  <row>
	    <entry>Standard Error</entry>
	    <entry>2</entry>
	    <entry>Error output to the console</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <para>So by default, all input will come from the keyboard and all
    output (both normal and error output) will go to the screen.</para>

    <figure>
      <title>Default Unix Files</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="chapter00/figures/stdfds.eps" format="EPS"></imagedata>
	</imageobject>
	<imageobject role="fo">
	  <imagedata fileref="chapter00/figures/stdfds.svg"
	  format="SVG" scalefit="1" width="100%"
	  contentdept="100%"></imagedata>
	</imageobject>
	<imageobject role="html">
	  <imagedata fileref="chapter00/figures/stdfds.png" format="PNG"></imagedata>
	</imageobject>
	<textobject>
	  <phrase>The standard files opened with any UNIX program.</phrase>
	</textobject>
      </mediaobject>
    </figure>

    <sect2>
      <title>The Shell</title> 
      
      <para>The shell is your gateway to interacting with the
      operating system.  It has only one major task -- to allow you to
      execute programs (you will begin to understand how the shell
      actually does this when we talk about some of the internals of
      the operating system later).</para>

      <para>But modern shells do much more than allow you to simply
      execute a program.  They have powerful abilities to redirect
      files, allow you to execute multiple programs simultaneously and
      script complete programs.</para>
      
    </sect2>

    <sect2>
      <title>Redirection</title> <para>Often we do not want the
      standard files mentioned above to point to their default places.
      For example, you may wish to capture all the output of a program
      into a file on disk, or, alternatively have it read its commands
      from a file you prepared earlier.  Another useful task might
      like to pass the output of one program to the input of another.
      It should come as no surprise you shell allows you to do all of
      this (and more!)</para>

    <table>
      <title>Standard Shell Redirection Facilities</title>
      <tgroup cols="4">
	<thead>
	  <row>
	    <entry>Name</entry>
	    <entry>Command</entry>
	    <entry>Description</entry>
	    <entry>Example</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>Redirect to a file</entry>
	    <entry><computeroutput>&gt; filename</computeroutput></entry>
	    <entry>Take all output from standard out and place it into
	    <computeroutput>filename</computeroutput>.  Note using
	    <computeroutput>&gt;&gt;</computeroutput> will append to
	    the file, rather than overwrite it.</entry>
	    <entry><computeroutput>ls &gt; filename</computeroutput></entry>
	  </row>
	  <row>
	    <entry>Read from a file</entry>
	    <entry>&lt; <computeroutput>filename</computeroutput></entry>
	    <entry>Copy all data from the file to the standard input of the program</entry>
	    <entry><computeroutput>echo &lt; filename</computeroutput></entry>
	  </row>
	  <row>
	    <entry>Pipe</entry>
	    <entry><computeroutput>program1 | program2</computeroutput></entry>
	    <entry>Take everything from standard out of
	    <computeroutput>program1</computeroutput> and pass it to
	    standard input of
	    <computeroutput>program2</computeroutput></entry>
	    <entry><computeroutput>ls | more</computeroutput></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    </sect2>


  </sect1>

</chapter>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("../csbu.xml" "book" "chapter")
End:
-->
